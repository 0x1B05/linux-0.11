#import "../template.typ": *

= 最开始的两行代码

#figure(caption: [])[#image("images/chapter1-1.png", width: 70%)]

按下开机键的那一刻，在主板上提前写死的固件程序 BIOS 会将硬盘中启动区的 512 字节，原封不动复制到内存中的 `0x7c00` 这个位置，并跳转到那个位置进行执行。

#definition("Definition")[
  只要硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节分别是 `0x55` 和 `0xaa`，那么 BIOS 就会认为它是个启动区。
]

此时的 BIOS 仅仅就是个代码搬运工，把 512 字节的二进制数据从硬盘搬运到了内存中而已。*作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并存储在硬盘的 0 盘 0 道 1 扇区即可。*

Linux-0.11 的 512 字节代码即`/boot/boootsect.s`, 通过编译，这个 `bootsect.s` 会被编译成二进制文件，存放在启动区的第一扇区。

#figure(caption: [])[#image("images/chapter1-2.png", width: 50%)]

RTFS从这个文件的第一行代码开始:
#figure(
```asm
mov ax,0x07c0
mov ds,ax
```,
caption: [最开始的两行代码]
)
含义是把 `0x07c0` 这个值复制到 `ax` 寄存器里，再将 `ax` 寄存器里的值复制到 `ds` 寄存器里。那其实这一番折腾的结果就是，让 `ds` 这个寄存器里的值变成了 `0x07c0`。

#figure(caption: [])[#image("images/chapter1-3.png", width:60%)]

#tip("Tip")[
ds 是一个 16 位的段寄存器，具体表示数据段寄存器，在*内存寻址*时充当段基址的作用。就是当我们之后用汇编语言写一个内存地址时，实际上仅仅是写了偏移地址，比如：

```asm
mov ax, [0x0001]
```

实际上相当于

```asm
mov ax, [ds:0x0001]
```

`ds` 是默认加上的，表示在 `ds` 这个段基址处，往后再偏移 `0x0001` 单位，将这个位置的内存数据，复制到 `ax` 寄存器中。
]

这个 `ds` 被赋值为了 `0x07c0`，由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素，所以段基址要先左移四位。那 `0x07c0` 左移四位就是 `0x7c00`，那这就刚好和这段代码被 BIOS 加载到的内存地址 `0x7c00` 一样了。
之后再写的代码，里面访问的数据的内存地址，都先默认加上 `0x7c00`，再去内存中寻址。
#tip("Tip")[
BIOS 规定死了把操作系统代码加载到内存 `0x7c00`
#figure(caption: [])[#image("images/chapter1-4.png", width:60%)]
]

#pagebreak()
