#import "../template.typ": *

= 新进程的诞生全局概述

到了第三部分，就是从内核态切换到用户态，然后通过 `fork` 创建出一个新的进程，再之后老进程进入死循环。

#figure(
```c
void main(void) {
    // 第二部分的内容，各种初始化工作
    ...
    // 第三部分的内容，一个新进程的诞生
    move_to_user_mode();
    if (!fork()) {
        // 新进程里干了啥，是第四部分的内容
        init();
    }
    // 死循环，操作系统怠速状态
    for(;;) pause();
}
```,
caption: [main - fork]
)

第一句是 `move_to_user_mode`，就是转变为用户态模式。

一旦转变为了用户态，那么之后的代码将一直处于用户态的模式，除非发生了中断，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。

#figure(caption: [])[#image("images/chapter21-1.png", width: 60%)]

第二句是 `fork`，这是创建一个新进程，而且所有用户进程想要创建新的进程，都需要调用这个函数。

原来操作系统只有一个执行流，就是一直看过来的所有代码，就是进程 0。调用完 fork 之后，现在又多了一个进程，叫做进程 1。

更准确的说法是，一路看过来的代码能够被我们自信地称作进程 0 的确切时刻，是 `sched_init` 里为当前执行流添加了一个进程管理结构到 `task` 数组里，同时开启了定时器以及时钟中断的那一个时刻。

#figure(caption: [])[#image("images/chapter21-2.png", width: 60%)]

第三句是 `init`，只有进程 1 会走到这个分支来执行。这里的代码很多，本身需要完成如加载根文件系统的任务，同时又会创建出一个新的进程 2，在进程 2 里又会加载与用户交互的 shell 程序，此时操作系统就正式成为了用户可用的一个状态了。

第四句是 `pause`，当没有任何可运行的进程时，操作系统会悬停在这里，达到怠速状态。

一共四句话，切换到用户态，创建新进程，初始化，然后悬停怠速。
#pagebreak()
